---
description: "Standards for TanStack Query (React Query) usage in API modules, defining hooks, keys, and caching. Apply this rule only when @tanstack/react-query is installed."
alwaysApply: false
---
# TanStack Query Implementation

## Requirements
- SKIP this rule entirely if `@tanstack/react-query` is not installed
- DO NOT install `@tanstack/react-query` if it is not present

## Required Context
- `@api-organization.mdc` — base API structure, fetchers, types. Read before proceeding.

This rule defines how to use TanStack Query for data fetching, mutations, and cache management in API modules.

## 1. Directory Structure

This rule specifically focuses on the `queries.ts` file within a domain folder.

```
src/api/
└── [domain-name]/
    └── queries.ts         # TanStack Query hooks and cache management
```

## 2. File Structure (queries.ts)

The `queries.ts` file should follow a consistent structure for readability and maintainability.

**Structure:**
1. Private `QueryKeys` enum (SCREAMING_SNAKE_CASE, not exported)
2. `use*` hooks for queries
3. `use*` hooks for mutations
4. `invalidate*` functions for cache invalidation
5. `set*` or other cache manipulation functions

**Pattern:**

```typescript
import { useQuery, useMutation } from '@tanstack/react-query';
import { queryClient } from '@/constants/query-client';
import { fetchProductById, createProduct, updateProduct, deleteProduct } from './module';
import type { ProductResponse, CreateProductPayload } from './types';

enum QueryKeys {
  PRODUCT = 'product',
  PRODUCT_LIST = 'product-list',
}

// Queries
export const useProductById = (productId: string) =>
  useQuery({
    queryKey: [QueryKeys.PRODUCT, productId],
    queryFn: () => fetchProductById(productId),
    retry: false,
  });

// Mutations
export const useCreateProduct = () =>
  useMutation({
    mutationFn: createProduct,
    onSuccess: () => {
      invalidateProductList();
    },
  });

export const useUpdateProduct = () =>
  useMutation({
    mutationFn: ({ productId, payload }: { productId: string; payload: UpdateProductPayload }) =>
      updateProduct(productId, payload),
  });

// Cache Management
export const invalidateProductList = () =>
  queryClient.invalidateQueries({ queryKey: [QueryKeys.PRODUCT_LIST] });

export const setProductData = (productId: string, productData: ProductResponse) => {
  queryClient.setQueryData<ProductResponse | undefined>(
    [QueryKeys.PRODUCT, productId],
    productData,
  );
};
```

## 3. Conditional Query Patterns

Use `skipToken` or the `enabled` property for conditional fetching.

### Using skipToken

```typescript
import { useQuery, skipToken } from '@tanstack/react-query';

export const useProductById = (productId: string, isSkipToken?: boolean) =>
  useQuery({
    queryKey: [QueryKeys.PRODUCT, productId],
    queryFn: isSkipToken ? skipToken : () => fetchProductById(productId),
  });
```

### Using enabled

```typescript
export const useProductById = (productId: string | null) =>
  useQuery({
    queryKey: [QueryKeys.PRODUCT, productId],
    queryFn: () => fetchProductById(productId),
    enabled: !!productId,
  });
```
